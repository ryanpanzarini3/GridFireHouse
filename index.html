<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fire House Grid Master</title>
    <link rel="icon" type="image/x-icon" href="/static/favicon.ico">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/feather-icons/dist/feather.min.js"></script>
    <script src="https://unpkg.com/feather-icons"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dragula/3.7.3/dragula.min.js"></script>
    <style>
        .grid-cell {
            width: 40px;
            height: 40px;
            border: 1px solid #2d3748;
            position: relative;
        }
        .grid-cell:hover {
            background-color: rgba(239, 68, 68, 0.2);
        }
        .token {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            position: absolute;
            top: 2px;
            left: 2px;
            cursor: move;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: bold;
            font-size: 0.8rem;
            user-select: none;
        }
        .token.selected {
            box-shadow: 0 0 0 3px rgba(239, 68, 68, 0.8);
        }
        .fire-overlay {
            background-color: rgba(239, 68, 68, 0.3);
        }
        .smoke-overlay {
            background-color: rgba(156, 163, 175, 0.3);
        }
        .ice-overlay {
            background-color: rgba(96, 165, 250, 0.3);
        }
        .flame-bg {
            background: linear-gradient(to bottom, #000000, #1a0000);
            position: relative;
            overflow: hidden;
        }
        .flame-bg::before {
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: radial-gradient(ellipse at center, rgba(239, 68, 68, 0.1) 0%, rgba(0, 0, 0, 0) 70%);
            animation: flicker 3s infinite alternate;
            z-index: -1;
        }
        .grid-cols-20 {
        grid-template-columns: repeat(20, 40px);
    }
    .grid-rows-20 {
        grid-template-rows: repeat(20, 40px);
    }
    body {
        min-height: 100vh;
        background: url('/imagens/firehouse.png') center center / cover no-repeat;
        color: white;
    }
        @keyframes flicker {
            0% { opacity: 0.5; }
            100% { opacity: 0.8; }
        }
        #battleGrid {
    background: rgba(30, 30, 30, 0.7); /* cinza escuro com 70% opacidade */
    border-radius: 12px;
    box-shadow: 0 2px 16px rgba(0,0,0,0.3);
}
    </style>
</head>
<body class="text-white">
    <div class="container mx-auto px-4 py-6">
        <!-- Header -->
        <header class="flex items-center justify-between mb-8">
            <div class="flex items-center">
                <div class="w-16 h-16 bg-red-600 rounded-full flex items-center justify-center mr-4">
                    <i data-feather="fire" class="w-8 h-8"></i>
                </div>
                <h1 class="text-3xl font-bold bg-gradient-to-r from-red-500 to-orange-500 bg-clip-text text-transparent">
                    Fire House Grid Master
                </h1>
            </div>
            <div class="flex space-x-4">
                <button id="saveBtn" class="px-4 py-2 bg-red-800 hover:bg-red-700 rounded-lg flex items-center">
                    <i data-feather="save" class="mr-2"></i> Save
                </button>
                <button id="exportBtn" class="px-4 py-2 bg-red-800 hover:bg-red-700 rounded-lg flex items-center">
                    <i data-feather="download" class="mr-2"></i> Export
                </button>
                <button id="importBtn" class="px-4 py-2 bg-red-800 hover:bg-red-700 rounded-lg flex items-center">
                    <i data-feather="upload" class="mr-2"></i> Import
                </button>
                <button id="clearBtn" class="px-4 py-2 bg-gray-800 hover:bg-gray-700 rounded-lg flex items-center">
                    <i data-feather="trash-2" class="mr-2"></i> Clear
                </button>
            </div>
        </header>

        <!-- Main Content -->
        <div class="flex flex-col lg:flex-row gap-6">
            <!-- Side Panel -->
            <div class="w-full lg:w-64 bg-gray-900 rounded-lg p-4">
                <h2 class="text-xl font-bold mb-4 text-red-400">Controls</h2>
                
                <div class="grid grid-cols-2 gap-2 mb-6">
                    <button id="addPlayerBtn" class="px-3 py-2 bg-blue-800 hover:bg-blue-700 rounded-lg flex items-center justify-center">
                        <i data-feather="user-plus" class="mr-2"></i> Player
                    </button>
                    <button id="addEnemyBtn" class="px-3 py-2 bg-red-800 hover:bg-red-700 rounded-lg flex items-center justify-center">
                        <i data-feather="skull" class="mr-2"></i> Enemy
                    </button>
                    <button id="markFireBtn" class="px-3 py-2 bg-orange-800 hover:bg-orange-700 rounded-lg flex items-center justify-center">
                        <i data-feather="flame" class="mr-2"></i> Fire
                    </button>
                    <button id="markSmokeBtn" class="px-3 py-2 bg-gray-800 hover:bg-gray-700 rounded-lg flex items-center justify-center">
                        <i data-feather="cloud" class="mr-2"></i> Smoke
                    </button>
                    <button id="markIceBtn" class="px-3 py-2 bg-blue-800 hover:bg-blue-700 rounded-lg flex items-center justify-center">
                        <i data-feather="droplet" class="mr-2"></i> Ice
                    </button>
                    <button id="clearMarksBtn" class="px-3 py-2 bg-gray-800 hover:bg-gray-700 rounded-lg flex items-center justify-center">
                        <i data-feather="x" class="mr-2"></i> Clear Marks
                    </button>
                </div>

                <h3 class="text-lg font-semibold mb-2 text-red-400">Tokens</h3>
                <div id="tokenList" class="space-y-2 max-h-96 overflow-y-auto">
                    <!-- Tokens will be listed here -->
                </div>
            </div>

            <!-- Grid Area -->
            <div class="flex-1">
                <div id="battleGrid" class="grid grid-cols-20 gap-0 border-2 border-red-800 mx-auto w-max">
                    <!-- Grid cells will be generated here -->
                </div>
            </div>
        </div>

        <!-- Footer -->
        <footer class="mt-8 bg-gray-900 rounded-lg p-4">
            <div class="flex justify-between items-center">
                <div id="selectedTokenInfo" class="text-lg">
                    No token selected
                </div>
                <div id="statusMessage" class="text-yellow-400 italic">
                    Ready for battle!
                </div>
                <div class="flex space-x-2" id="tokenControls">
                    <button id="moveUpBtn" class="p-2 bg-gray-800 rounded-lg" disabled>
                        <i data-feather="arrow-up"></i>
                    </button>
                    <button id="moveLeftBtn" class="p-2 bg-gray-800 rounded-lg" disabled>
                        <i data-feather="arrow-left"></i>
                    </button>
                    <button id="moveRightBtn" class="p-2 bg-gray-800 rounded-lg" disabled>
                        <i data-feather="arrow-right"></i>
                    </button>
                    <button id="moveDownBtn" class="p-2 bg-gray-800 rounded-lg" disabled>
                        <i data-feather="arrow-down"></i>
                    </button>
                    <button id="deleteTokenBtn" class="p-2 bg-red-800 rounded-lg" disabled>
                        <i data-feather="trash-2"></i>
                    </button>
                </div>
            </div>
        </footer>
    </div>

    <!-- Token Edit Modal -->
    <div id="tokenModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden z-50">
        <div class="bg-gray-900 rounded-lg p-6 w-full max-w-md">
            <h3 class="text-xl font-bold mb-4" id="modalTitle">Edit Token</h3>
            
            <div class="space-y-4">
                <div>
                    <label class="block text-sm font-medium mb-1">Name</label>
                    <input type="text" id="tokenNameInput" class="w-full bg-gray-800 border border-gray-700 rounded-lg px-3 py-2">
                </div>
                
                <div class="grid grid-cols-2 gap-4">
                    <div>
                        <label class="block text-sm font-medium mb-1">HP</label>
                        <input type="number" id="tokenHpInput" class="w-full bg-gray-800 border border-gray-700 rounded-lg px-3 py-2">
                    </div>
                    <div>
                        <label class="block text-sm font-medium mb-1">Max HP</label>
                        <input type="number" id="tokenMaxHpInput" class="w-full bg-gray-800 border border-gray-700 rounded-lg px-3 py-2">
                    </div>
                </div>
                
                <div>
                    <label class="block text-sm font-medium mb-1">Initiative</label>
                    <input type="number" id="tokenInitiativeInput" class="w-full bg-gray-800 border border-gray-700 rounded-lg px-3 py-2">
                </div>
                
                <div>
                    <label class="block text-sm font-medium mb-1">Color</label>
                    <select id="tokenColorSelect" class="w-full bg-gray-800 border border-gray-700 rounded-lg px-3 py-2">
                        <option value="bg-red-600">Red</option>
                        <option value="bg-blue-600">Blue</option>
                        <option value="bg-green-600">Green</option>
                        <option value="bg-purple-600">Purple</option>
                        <option value="bg-yellow-600">Yellow</option>
                    </select>
                </div>
                
                <div class="flex justify-end space-x-3 pt-4">
                    <button id="cancelTokenEditBtn" class="px-4 py-2 bg-gray-800 hover:bg-gray-700 rounded-lg">
                        Cancel
                    </button>
                    <button id="saveTokenBtn" class="px-4 py-2 bg-red-800 hover:bg-red-700 rounded-lg">
                        Save
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize Feather Icons
            feather.replace();
            
            // Game state
            const state = {
                gridSize: 20,
                cells: [],
                tokens: [],
                selectedToken: null,
                currentMarkType: null,
                nextTokenId: 1
            };

            // DOM elements
            const gridElement = document.getElementById('battleGrid');
            const tokenListElement = document.getElementById('tokenList');
            const selectedTokenInfoElement = document.getElementById('selectedTokenInfo');
            const statusMessageElement = document.getElementById('statusMessage');
            const tokenModalElement = document.getElementById('tokenModal');
            
            // Initialize the grid
            function initializeGrid() {
                gridElement.innerHTML = '';
                state.cells = [];
                
                for (let y = 0; y < state.gridSize; y++) {
                    for (let x = 0; x < state.gridSize; x++) {
                        const cell = document.createElement('div');
                        cell.className = 'grid-cell';
                        cell.dataset.x = x;
                        cell.dataset.y = y;
                        
                        cell.addEventListener('click', handleCellClick);
                        cell.addEventListener('dragover', handleDragOver);
                        cell.addEventListener('drop', handleDrop);
                        
                        gridElement.appendChild(cell);
                        state.cells.push({
                            element: cell,
                            x: x,
                            y: y,
                            marks: []
                        });
                    }
                }
            }

            // Handle cell clicks (for marking areas)
            function handleCellClick(e) {
                const cell = e.currentTarget;
                const x = parseInt(cell.dataset.x);
                const y = parseInt(cell.dataset.y);
                const cellData = getCellData(x, y);
                
                if (state.currentMarkType) {
                    // Toggle mark
                    const markIndex = cellData.marks.indexOf(state.currentMarkType);
                    if (markIndex >= 0) {
                        cellData.marks.splice(markIndex, 1);
                        cell.classList.remove(`${state.currentMarkType}-overlay`);
                    } else {
                        cellData.marks.push(state.currentMarkType);
                        cell.classList.add(`${state.currentMarkType}-overlay`);
                    }
                    saveState();
                }
            }

            // Handle drag over for token dropping
            function handleDragOver(e) {
                e.preventDefault();
            }

            // Handle token drops
            function handleDrop(e) {
                e.preventDefault();
                const cell = e.currentTarget;
                const x = parseInt(cell.dataset.x);
                const y = parseInt(cell.dataset.y);
                
                const tokenId = e.dataTransfer.getData('text/plain');
                const token = state.tokens.find(t => t.id === tokenId);
                
                if (token) {
                    // Check if new position is valid
                    if (isPositionValid(x, y, token.size)) {
                        moveToken(token, x, y);
                    }
                }
            }

            // Check if position is valid for token placement
            function isPositionValid(x, y, size = 1) {
                // Check boundaries
                if (x < 0 || y < 0 || x + size > state.gridSize || y + size > state.gridSize) {
                    return false;
                }
                
                // Check if space is occupied
                for (let dy = 0; dy < size; dy++) {
                    for (let dx = 0; dx < size; dx++) {
                        const cell = getCellData(x + dx, y + dy);
                        if (cell.tokenId) {
                            return false;
                        }
                    }
                }
                
                return true;
            }

            // Get cell data by coordinates
            function getCellData(x, y) {
                return state.cells[y * state.gridSize + x];
            }

            // Create a new token
            function createToken(type, x, y) {
                const tokenId = `token-${state.nextTokenId++}`;
                const colors = {
                    player: 'bg-blue-600',
                    enemy: 'bg-red-600'
                };
                
                const token = {
                    id: tokenId,
                    name: type === 'player' ? `Player ${state.tokens.filter(t => t.type === 'player').length + 1}` : `Enemy ${state.tokens.filter(t => t.type === 'enemy').length + 1}`,
                    type: type,
                    x: x,
                    y: y,
                    size: 1,
                    hp: type === 'player' ? 30 : 15,
                    maxHp: type === 'player' ? 30 : 15,
                    initiative: 0,
                    color: colors[type]
                };
                
                state.tokens.push(token);
                renderToken(token);
                saveState();
                
                return token;
            }

            // Render a token on the grid
            function renderToken(token) {
                // Remove existing token element if it exists
                const existingElement = document.getElementById(token.id);
                if (existingElement) {
                    existingElement.remove();
                }
                
                // Create new token element
                const tokenElement = document.createElement('div');
                tokenElement.id = token.id;
                tokenElement.className = `token ${token.color} ${token.selected ? 'selected' : ''}`;
                tokenElement.textContent = token.name.charAt(0);
                tokenElement.title = `${token.name}\nHP: ${token.hp}/${token.maxHp}`;
                
                tokenElement.draggable = true;
                tokenElement.addEventListener('dragstart', handleTokenDragStart);
                tokenElement.addEventListener('click', () => selectToken(token));
                
                // Position the token
                const cell = getCellData(token.x, token.y);
                cell.element.appendChild(tokenElement);
                
                // Mark cells as occupied
                for (let dy = 0; dy < token.size; dy++) {
                    for (let dx = 0; dx < token.size; dx++) {
                        const occupiedCell = getCellData(token.x + dx, token.y + dy);
                        occupiedCell.tokenId = token.id;
                    }
                }
                
                // Update token list
                updateTokenList();
            }

            // Handle token drag start
            function handleTokenDragStart(e) {
                e.dataTransfer.setData('text/plain', e.target.id);
            }

            // Move a token to new coordinates
            function moveToken(token, newX, newY) {
                // Clear old position
                for (let dy = 0; dy < token.size; dy++) {
                    for (let dx = 0; dx < token.size; dx++) {
                        const oldCell = getCellData(token.x + dx, token.y + dy);
                        oldCell.tokenId = null;
                    }
                }
                
                // Update token position
                token.x = newX;
                token.y = newY;
                
                // Mark new position as occupied
                for (let dy = 0; dy < token.size; dy++) {
                    for (let dx = 0; dx < token.size; dx++) {
                        const newCell = getCellData(token.x + dx, token.y + dy);
                        newCell.tokenId = token.id;
                    }
                }
                
                renderToken(token);
                saveState();
                showStatusMessage(`Moved ${token.name} to ${String.fromCharCode(65 + newX)}${newY + 1}`);
            }

            // Select a token
            function selectToken(token) {
                // Deselect previously selected token
                if (state.selectedToken) {
                    state.selectedToken.selected = false;
                    renderToken(state.selectedToken);
                }
                
                // Select new token
                state.selectedToken = token;
                token.selected = true;
                renderToken(token);
                
                // Update UI
                selectedTokenInfoElement.textContent = `${token.name} (${token.hp}/${token.maxHp} HP)`;
                
                // Enable token controls
                document.getElementById('moveUpBtn').disabled = false;
                document.getElementById('moveLeftBtn').disabled = false;
                document.getElementById('moveRightBtn').disabled = false;
                document.getElementById('moveDownBtn').disabled = false;
                document.getElementById('deleteTokenBtn').disabled = false;
            }

            // Update the token list in the side panel
            function updateTokenList() {
                tokenListElement.innerHTML = '';
                
                state.tokens.forEach(token => {
                    const tokenElement = document.createElement('div');
                    tokenElement.className = `flex items-center justify-between p-2 rounded-lg ${token.type === 'player' ? 'bg-blue-900' : 'bg-red-900'}`;
                    
                    tokenElement.innerHTML = `
                        <div class="flex items-center">
                            <div class="w-6 h-6 rounded-full ${token.color} mr-2 flex items-center justify-center text-xs font-bold">${token.name.charAt(0)}</div>
                            <span>${token.name}</span>
                        </div>
                        <div class="flex space-x-2">
                            <button class="edit-token-btn p-1 rounded hover:bg-gray-700" data-id="${token.id}">
                                <i data-feather="edit-2" class="w-4 h-4"></i>
                            </button>
                            <button class="delete-token-btn p-1 rounded hover:bg-gray-700" data-id="${token.id}">
                                <i data-feather="trash-2" class="w-4 h-4"></i>
                            </button>
                        </div>
                    `;
                    
                    tokenListElement.appendChild(tokenElement);
                    
                    // Add event listeners for the buttons
                    tokenElement.querySelector('.edit-token-btn').addEventListener('click', () => openTokenEditor(token));
                    tokenElement.querySelector('.delete-token-btn').addEventListener('click', () => deleteToken(token));
                });
                
                feather.replace();
            }

            // Open token editor modal
            function openTokenEditor(token) {
                document.getElementById('tokenNameInput').value = token.name;
                document.getElementById('tokenHpInput').value = token.hp;
                document.getElementById('tokenMaxHpInput').value = token.maxHp;
                document.getElementById('tokenInitiativeInput').value = token.initiative;
                
                // Set color select
                const colorSelect = document.getElementById('tokenColorSelect');
                for (let i = 0; i < colorSelect.options.length; i++) {
                    if (colorSelect.options[i].value === token.color) {
                        colorSelect.selectedIndex = i;
                        break;
                    }
                }
                
                // Store which token we're editing
                tokenModalElement.dataset.editingTokenId = token.id;
                tokenModalElement.classList.remove('hidden');
            }

            // Save token changes from modal
            function saveTokenChanges() {
                const tokenId = tokenModalElement.dataset.editingTokenId;
                const token = state.tokens.find(t => t.id === tokenId);
                
                if (token) {
                    token.name = document.getElementById('tokenNameInput').value;
                    token.hp = parseInt(document.getElementById('tokenHpInput').value) || 0;
                    token.maxHp = parseInt(document.getElementById('tokenMaxHpInput').value) || 0;
                    token.initiative = parseInt(document.getElementById('tokenInitiativeInput').value) || 0;
                    token.color = document.getElementById('tokenColorSelect').value;
                    
                    renderToken(token);
                    updateTokenList();
                    saveState();
                    
                    if (token.id === state.selectedToken?.id) {
                        selectedTokenInfoElement.textContent = `${token.name} (${token.hp}/${token.maxHp} HP)`;
                    }
                }
                
                tokenModalElement.classList.add('hidden');
            }

            // Delete a token
            function deleteToken(token) {
                if (confirm(`Delete ${token.name}?`)) {
                    // Clear cells occupied by this token
                    for (let dy = 0; dy < token.size; dy++) {
                        for (let dx = 0; dx < token.size; dx++) {
                            const cell = getCellData(token.x + dx, token.y + dy);
                            cell.tokenId = null;
                        }
                    }
                    
                    // Remove token from array
                    state.tokens = state.tokens.filter(t => t.id !== token.id);
                    
                    // Remove token element
                    const tokenElement = document.getElementById(token.id);
                    if (tokenElement) {
                        tokenElement.remove();
                    }
                    
                    // If this was the selected token, clear selection
                    if (state.selectedToken && state.selectedToken.id === token.id) {
                        state.selectedToken = null;
                        selectedTokenInfoElement.textContent = 'No token selected';
                        
                        // Disable token controls
                        document.getElementById('moveUpBtn').disabled = true;
                        document.getElementById('moveLeftBtn').disabled = true;
                        document.getElementById('moveRightBtn').disabled = true;
                        document.getElementById('moveDownBtn').disabled = true;
                        document.getElementById('deleteTokenBtn').disabled = true;
                    }
                    
                    updateTokenList();
                    saveState();
                    showStatusMessage(`Deleted ${token.name}`);
                }
            }

            // Show a status message
            function showStatusMessage(message) {
                statusMessageElement.textContent = message;
                setTimeout(() => {
                    if (statusMessageElement.textContent === message) {
                        statusMessageElement.textContent = 'Ready for battle!';
                    }
                }, 3000);
            }

            // Save state to localStorage
            function saveState() {
                const saveData = {
                    tokens: state.tokens,
                    cells: state.cells.map(cell => ({
                        x: cell.x,
                        y: cell.y,
                        marks: [...cell.marks]
                    })),
                    nextTokenId: state.nextTokenId
                };
                
                localStorage.setItem('infernalBattleGrid', JSON.stringify(saveData));
            }

            // Load state from localStorage
            function loadState() {
                const savedData = localStorage.getItem('infernalBattleGrid');
                if (savedData) {
                    try {
                        const data = JSON.parse(savedData);
                        
                        // Clear existing state
                        state.tokens = [];
                        state.nextTokenId = data.nextTokenId;
                        
                        // Restore cells
                        data.cells.forEach(cellData => {
                            const cell = getCellData(cellData.x, cellData.y);
                            cell.marks = [...cellData.marks];
                            
                            // Apply marks visually
                            cellData.marks.forEach(mark => {
                                cell.element.classList.add(`${mark}-overlay`);
                            });
                        });
                        
                        // Restore tokens
                        data.tokens.forEach(tokenData => {
                            const token = {
                                ...tokenData,
                                selected: false
                            };
                            state.tokens.push(token);
                            
                            // Mark cells as occupied
                            for (let dy = 0; dy < token.size; dy++) {
                                for (let dx = 0; dx < token.size; dx++) {
                                    const cell = getCellData(token.x + dx, token.y + dy);
                                    cell.tokenId = token.id;
                                }
                            }
                            
                            renderToken(token);
                        });
                        
                        showStatusMessage('Game loaded successfully');
                    } catch (e) {
                        console.error('Failed to load saved data:', e);
                        showStatusMessage('Failed to load saved game');
                    }
                }
            }

            // Export current state to JSON file
            function exportState() {
                const saveData = {
                    tokens: state.tokens,
                    cells: state.cells.map(cell => ({
                        x: cell.x,
                        y: cell.y,
                        marks: [...cell.marks]
                    })),
                    nextTokenId: state.nextTokenId
                };
                
                const dataStr = JSON.stringify(saveData, null, 2);
                const dataUri = 'data:application/json;charset=utf-8,' + encodeURIComponent(dataStr);
                
                const exportFileDefaultName = 'infernal-battle-grid.json';
                const linkElement = document.createElement('a');
                linkElement.setAttribute('href', dataUri);
                linkElement.setAttribute('download', exportFileDefaultName);
                linkElement.click();
                
                showStatusMessage('Game exported successfully');
            }

            // Import state from JSON file
            function importState(file) {
                const reader = new FileReader();
                
                reader.onload = function(e) {
                    try {
                        const data = JSON.parse(e.target.result);
                        
                        // Clear current state
                        clearGrid(false);
                        
                        // Load new state
                        state.tokens = [];
                        state.nextTokenId = data.nextTokenId;
                        
                        // Restore cells
                        data.cells.forEach(cellData => {
                            const cell = getCellData(cellData.x, cellData.y);
                            cell.marks = [...cellData.marks];
                            
                            // Apply marks visually
                            cellData.marks.forEach(mark => {
                                cell.element.classList.add(`${mark}-overlay`);
                            });
                        });
                        
                        // Restore tokens
                        data.tokens.forEach(tokenData => {
                            const token = {
                                ...tokenData,
                                selected: false
                            };
                            state.tokens.push(token);
                            
                            // Mark cells as occupied
                            for (let dy = 0; dy < token.size; dy++) {
                                for (let dx = 0; dx < token.size; dx++) {
                                    const cell = getCellData(token.x + dx, token.y + dy);
                                    cell.tokenId = token.id;
                                }
                            }
                            
                            renderToken(token);
                        });
                        
                        showStatusMessage('Game imported successfully');
                    } catch (e) {
                        console.error('Failed to import data:', e);
                        showStatusMessage('Failed to import game - invalid file');
                    }
                };
                
                reader.readAsText(file);
            }

            // Clear the grid
            function clearGrid(confirmFirst = true) {
                if (confirmFirst && !confirm('Clear the entire grid? This cannot be undone.')) {
                    return;
                }
                
                // Clear all tokens
                state.tokens = [];
                state.selectedToken = null;
                state.nextTokenId = 1;
                
                // Clear all cells
                state.cells.forEach(cell => {
                    cell.tokenId = null;
                    cell.marks = [];
                    cell.element.className = 'grid-cell';
                    cell.element.classList.remove('fire-overlay', 'smoke-overlay', 'ice-overlay');
                });
                
                // Update UI
                selectedTokenInfoElement.textContent = 'No token selected';
                updateTokenList();
                showStatusMessage('Grid cleared');
                
                if (!confirmFirst) {
                    saveState();
                }
            }

            // Find random empty position
            function findRandomEmptyPosition(size = 1) {
                const emptyCells = state.cells.filter(cell => 
                    !cell.tokenId && 
                    isPositionValid(cell.x, cell.y, size)
                );
                
                if (emptyCells.length === 0) {
                    return null;
                }
                
                const randomCell = emptyCells[Math.floor(Math.random() * emptyCells.length)];
                return { x: randomCell.x, y: randomCell.y };
            }

            // Set up button event listeners
            function setupEventListeners() {
                // Add player/enemy buttons
                document.getElementById('addPlayerBtn').addEventListener('click', () => {
                    const position = findRandomEmptyPosition();
                    if (position) {
                        const token = createToken('player', position.x, position.y);
                        selectToken(token);
                        openTokenEditor(token);
                    } else {
                        showStatusMessage('No empty space for new token');
                    }
                });
                
                document.getElementById('addEnemyBtn').addEventListener('click', () => {
                    const position = findRandomEmptyPosition();
                    if (position) {
                        const token = createToken('enemy', position.x, position.y);
                        selectToken(token);
                        openTokenEditor(token);
                    } else {
                        showStatusMessage('No empty space for new token');
                    }
                });
                
                // Marking buttons
                document.getElementById('markFireBtn').addEventListener('click', () => {
                    state.currentMarkType = state.currentMarkType === 'fire' ? null : 'fire';
                    updateMarkButtons();
                });
                
                document.getElementById('markSmokeBtn').addEventListener('click', () => {
                    state.currentMarkType = state.currentMarkType === 'smoke' ? null : 'smoke';
                    updateMarkButtons();
                });
                
                document.getElementById('markIceBtn').addEventListener('click', () => {
                    state.currentMarkType = state.currentMarkType === 'ice' ? null : 'ice';
                    updateMarkButtons();
                });
                
                document.getElementById('clearMarksBtn').addEventListener('click', () => {
                    state.currentMarkType = null;
                    updateMarkButtons();
                    
                    // Clear all marks
                    state.cells.forEach(cell => {
                        cell.marks = [];
                        cell.element.classList.remove('fire-overlay', 'smoke-overlay', 'ice-overlay');
                    });
                    
                    saveState();
                    showStatusMessage('Cleared all marks');
                });
                
                // Save/load buttons
                document.getElementById('saveBtn').addEventListener('click', () => {
                    saveState();
                    showStatusMessage('Game saved');
                });
                
                document.getElementById('exportBtn').addEventListener('click', exportState);
                
                document.getElementById('importBtn').addEventListener('click', () => {
                    const fileInput = document.createElement('input');
                    fileInput.type = 'file';
                    fileInput.accept = '.json';
                    
                    fileInput.addEventListener('change', (e) => {
                        if (e.target.files.length > 0) {
                            importState(e.target.files[0]);
                        }
                    });
                    
                    fileInput.click();
                });
                
                document.getElementById('clearBtn').addEventListener('click', () => clearGrid());
                
                // Token movement buttons
                document.getElementById('moveUpBtn').addEventListener('click', () => {
                    if (state.selectedToken && isPositionValid(state.selectedToken.x, state.selectedToken.y - 1, state.selectedToken.size)) {
                        moveToken(state.selectedToken, state.selectedToken.x, state.selectedToken.y - 1);
                    }
                });
                
                document.getElementById('moveLeftBtn').addEventListener('click', () => {
                    if (state.selectedToken && isPositionValid(state.selectedToken.x - 1, state.selectedToken.y, state.selectedToken.size)) {
                        moveToken(state.selectedToken, state.selectedToken.x - 1, state.selectedToken.y);
                    }
                });
                
                document.getElementById('moveRightBtn').addEventListener('click', () => {
                    if (state.selectedToken && isPositionValid(state.selectedToken.x + 1, state.selectedToken.y, state.selectedToken.size)) {
                        moveToken(state.selectedToken, state.selectedToken.x + 1, state.selectedToken.y);
                    }
                });
                
                document.getElementById('moveDownBtn').addEventListener('click', () => {
                    if (state.selectedToken && isPositionValid(state.selectedToken.x, state.selectedToken.y + 1, state.selectedToken.size)) {
                        moveToken(state.selectedToken, state.selectedToken.x, state.selectedToken.y + 1);
                    }
                });
                
                document.getElementById('deleteTokenBtn').addEventListener('click', () => {
                    if (state.selectedToken) {
                        deleteToken(state.selectedToken);
                    }
                });
                
                // Modal buttons
                document.getElementById('cancelTokenEditBtn').addEventListener('click', () => {
                    tokenModalElement.classList.add('hidden');
                });
                
                document.getElementById('saveTokenBtn').addEventListener('click', saveTokenChanges);
            }

            // Update mark buttons to show active state
            function updateMarkButtons() {
                const buttons = {
                    fire: document.getElementById('markFireBtn'),
                    smoke: document.getElementById('markSmokeBtn'),
                    ice: document.getElementById('markIceBtn')
                };
                
                // Reset all buttons
                Object.values(buttons).forEach(btn => {
                    btn.classList.remove('border-2', 'border-yellow-400');
                });
                
                // Highlight active button
                if (state.currentMarkType && buttons[state.currentMarkType]) {
                    buttons[state.currentMarkType].classList.add('border-2', 'border-yellow-400');
                }
            }

            // Keyboard controls
            document.addEventListener('keydown', (e) => {
                if (!state.selectedToken) return;
                
                switch (e.key) {
                    case 'ArrowUp':
                        document.getElementById('moveUpBtn').click();
                        e.preventDefault();
                        break;
                    case 'ArrowLeft':
                        document.getElementById('moveLeftBtn').click();
                        e.preventDefault();
                        break;
                    case 'ArrowRight':
                        document.getElementById('moveRightBtn').click();
                        e.preventDefault();
                        break;
                    case 'ArrowDown':
                        document.getElementById('moveDownBtn').click();
                        e.preventDefault();
                        break;
                    case 'Delete':
                        document.getElementById('deleteTokenBtn').click();
                        e.preventDefault();
                        break;
                }
            });

            // Initialize the application
            function init() {
                initializeGrid();
                setupEventListeners();
                loadState();
                
                // Disable token controls initially
                document.getElementById('moveUpBtn').disabled = true;
                document.getElementById('moveLeftBtn').disabled = true;
                document.getElementById('moveRightBtn').disabled = true;
                document.getElementById('moveDownBtn').disabled = true;
                document.getElementById('deleteTokenBtn').disabled = true;
            }

            // Start the app
            init();
        });
    </script>
</body>
</html>
